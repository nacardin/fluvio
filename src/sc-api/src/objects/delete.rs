//!
//! # Delete object
//!
//!

use std::io::Error;
use std::io::ErrorKind;

use log::trace;

use kf_protocol::Encoder;
use kf_protocol::Decoder;
use kf_protocol::Version;
use kf_protocol::bytes::{Buf, BufMut};
use kf_protocol::api::Request;
use flv_metadata::topic::TopicSpec;
use flv_metadata::spu::CustomSpuSpec;
use flv_metadata::spg::SpuGroupSpec;
use flv_metadata::core::Spec;

use crate::FlvStatus;
use crate::ScPublicApiKey;
use crate::AdminRequest;

// This can be auto generated by enum derive later
#[derive(Debug)]
pub enum DeleteRequest {
    Topic(String),
    CustomSpu(CustomSpecKey),
    SpuGroup(String)
}

impl Default for DeleteRequest {
    fn default() -> Self {
        DeleteRequest::CustomSpu(CustomSpecKey::Id(0))
    }
}

impl DeleteRequest {

    /// type represent as string
    fn type_string(&self) -> &'static str {
        match self {
            Self::Topic(_) => TopicSpec::LABEL,
            Self::CustomSpu(_) => CustomSpuSpec::LABEL,
            Self::SpuGroup(_) =>  SpuGroupSpec::LABEL
        }
    }
}


impl AdminRequest for DeleteRequest{}

impl Request for DeleteRequest {
    const API_KEY: u16 = ScPublicApiKey::Delete as u16;
    const DEFAULT_API_VERSION: i16 = 1;
    type Response = FlvStatus;
}


impl Encoder for DeleteRequest {
   
    fn write_size(&self, version: Version) -> usize {
        let type_size = self.type_string().to_owned().write_size(version);
     
        type_size
            + match self {
                Self::Topic(s) => s.write_size(version),
                Self::CustomSpu(s) => s.write_size(version),
                Self::SpuGroup(s) => s.write_size(version),
            }
    }

    // encode match
    fn encode<T>(&self, dest: &mut T, version: Version) -> Result<(), Error>
    where
        T: BufMut,
    {

        self.type_string().to_owned().encode(dest,version)?;

        match self {
            Self::Topic(s) => s.encode(dest, version)?,
            Self::CustomSpu(s) => s.encode(dest, version)?,
            Self::SpuGroup(s) => s.encode(dest, version)?
        }

        Ok(())
    }
}

impl Decoder for DeleteRequest {
    fn decode<T>(&mut self, src: &mut T, version: Version) -> Result<(), Error>
    where
        T: Buf,
    {
        let mut typ = "".to_owned();
        typ.decode(src, version)?;
        trace!("decoded type: {}", typ);

        match typ.as_ref() {
            TopicSpec::LABEL => {
                let mut response = String::default();
                response.decode(src, version)?;
                *self = Self::Topic(response);
                Ok(())
            },

            CustomSpuSpec::LABEL => {
                let mut response = CustomSpecKey::default();
                response.decode(src, version)?;
                *self = Self::CustomSpu(response);
                Ok(())
            },

            SpuGroupSpec::LABEL => {
                let mut response = String::default();
                response.decode(src, version)?;
                *self = Self::SpuGroup(response);
                Ok(())
            },

            // Unexpected type
            _ => Err(Error::new(
                ErrorKind::InvalidData,
                format!("invalid spec type {}", typ),
            )),
        }
    }
}



// This can be auto generated by enum derive later
#[derive(Debug)]
pub enum CustomSpecKey {
    Name(String),
    Id(i32)
}

impl CustomSpecKey {
    fn type_string(&self) -> &'static str {
        match self {
            Self::Name(_) => "Name",
            Self::Id(_) => "Id"
        }
    }
}

impl Default for CustomSpecKey {
    fn default() -> Self {
        Self::Id(0)
    }
   
}


impl Encoder for CustomSpecKey {
   
    fn write_size(&self, version: Version) -> usize {
        let type_size = self.type_string().to_owned().write_size(version);
     
        type_size
            + match self {
                Self::Name(s) => s.write_size(version),
                Self::Id(s) => s.write_size(version),
            }
    }

    // encode match
    fn encode<T>(&self, dest: &mut T, version: Version) -> Result<(), Error>
    where
        T: BufMut,
    {

        self.type_string().to_owned().encode(dest,version)?;

        match self {
            Self::Name(s) => s.encode(dest, version)?,
            Self::Id(s) => s.encode(dest, version)?,
        }

        Ok(())
    }
}

impl Decoder for CustomSpecKey {
    fn decode<T>(&mut self, src: &mut T, version: Version) -> Result<(), Error>
    where
        T: Buf,
    {
        let mut typ = "".to_owned();
        typ.decode(src, version)?;
        trace!("decoded type: {}", typ);

        match typ.as_ref() {
            "Name" => {
                let mut response = String::default();
                response.decode(src, version)?;
                *self = Self::Name(response);
                Ok(())
            },

            "Id" => {
                let mut response: i32 = 9;
                response.decode(src, version)?;
                *self = Self::Id(response);
                Ok(())
            },


            // Unexpected type
            _ => Err(Error::new(
                ErrorKind::InvalidData,
                format!("invalid spec type {}", typ),
            )),
        }
    }
}
